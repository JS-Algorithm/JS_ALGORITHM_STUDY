// 브루트포스 알고리즘
const input = require('fs').readFileSync('ex.txt').toString().split('\n');
const [N, M] = input[0].split(' ').map((v) => Number(v));
const board = input.slice(1).map((v) => v.split(' ').map((v) => Number(v)));

const solution = (N, M, board) => {
  const tetromino = {
    // ****
    1: [
      [0, 0],
      [0, 1],
      [0, 2],
      [0, 3],
    ],
    // *
    // *
    // *
    // *
    2: [
      [0, 0],
      [1, 0],
      [2, 0],
      [3, 0],
    ],
    // **
    // **
    3: [
      [0, 0],
      [0, 1],
      [1, 0],
      [1, 1],
    ],
    // *
    // *
    // **
    4: [
      [0, 0],
      [1, 0],
      [2, 0],
      [2, 1],
    ],
    //   *
    // ***
    5: [
      [0, 2],
      [1, 0],
      [1, 1],
      [1, 2],
    ],
    // **
    //  *
    //  *
    6: [
      [0, 0],
      [0, 1],
      [1, 1],
      [2, 1],
    ],
    // ***
    // *
    7: [
      [0, 0],
      [0, 1],
      [0, 2],
      [1, 0],
    ],
    // *
    // **
    //  *
    8: [
      [0, 0],
      [1, 0],
      [1, 1],
      [2, 1],
    ],
    //  **
    // **
    9: [
      [0, 1],
      [0, 2],
      [1, 0],
      [1, 1],
    ],
    // ***
    //  *
    10: [
      [0, 0],
      [0, 1],
      [0, 2],
      [1, 1],
    ],
    // *
    // **
    // *
    11: [
      [0, 0],
      [1, 0],
      [1, 1],
      [2, 0],
    ],
    //  *
    // ***
    12: [
      [0, 1],
      [1, 0],
      [1, 1],
      [1, 2],
    ],
    //  *
    // **
    //  *
    13: [
      [0, 1],
      [1, 0],
      [1, 1],
      [2, 1],
    ],
    //  *
    //  *
    // **
    14: [
      [0, 1],
      [1, 1],
      [2, 0],
      [2, 1],
    ],
    // *
    // ***
    15: [
      [0, 0],
      [1, 0],
      [1, 1],
      [1, 2],
    ],
    // **
    // *
    // *
    16: [
      [0, 0],
      [0, 1],
      [1, 0],
      [2, 0],
    ],
    // ***
    //   *
    17: [
      [0, 0],
      [0, 1],
      [0, 2],
      [1, 2],
    ],
    //  *
    // **
    // *
    18: [
      [0, 1],
      [1, 0],
      [1, 1],
      [2, 0],
    ],
    // **
    //  **
    19: [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 2],
    ],
  };
  let max = 0;
  let sum, x, y, flag;
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < M; j++) {
      for (const blocks of Object.values(tetromino)) {
        sum = 0;
        flag = true;
        for (let k = 0; k < 4; k++) {
          [y, x] = blocks[k];
          if (y + i >= N || x + j >= M) {
            flag = false; // 판을 넘어갈 경우
            break;
          }
          if (flag) sum += board[y + i][x + j];
        }
        max = Math.max(max, sum); // 큰 걸로 갱신
      }
    }
  }
  return max;
};

console.log(solution(N, M, board));
