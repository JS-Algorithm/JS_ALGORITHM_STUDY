// 1. 규칙을 찾아서 이전의 값을 기반으로 메모이제이션을 실행해보자.
// 2. 첫번째 날은 무조건 한 알만을 꺼낼 수밖에 없다.
// 3. 마지막 날 (2N) 은 무조건 반 알만을 꺼낼 수밖에 없다. (반알만 드시니까)
// 4. 반 조각을 꺼내려면 이전에 무조건 한 조각을 꺼내야 한다. (W가 지금까지 1개 나왔다면 H는 1개만 가능하다는 뜻)

/**
 * [정답 열람] : 규칙으로 해결하기가 도저히 안되겠어서...
 * DP[W][H] : 통짜 알약 W개와 반쪽짜리 알약 H 개를 먹을 수 있는 경우의 수
 * W = 1, H = 0부터 시작하는 것이 당연하다 (처음에는 큰 알약만 뽑기 가능)
 *
 * w와 h로 표현 가능한 길이가 N 인 문자열의 경우의 수는 이렇게 구할 수 있다.
 * [w가 N - 1 개이고, h가 N개인 경우의 수 + w가 N개이고 h가 N - 1개인 경우의 수의 합]
 * 따라서 점화식은 dp[w][h] = dp[w - 1][h] + dp[w][h - 1] 이다.
 *
 * 즉, 이 경우는 온전한 알약을 먹었을 경우 1을 빼주고 쪼개진 알약 하나를 추가해준 것과
 * 온전한 알약을 먹지 않고 쪼개진 알약 하나를 먹는 경우를 추가해준 것을 더하는 경우다.
 */

const input = require('fs')
  .readFileSync('/dev/stdin')
  .toString()
  .trimEnd()
  .split('\n')
  .map(Number);

const dp = Array.from({length: 31}, () => new Array(31).fill(0));

// H가 0인 경우는 무조건 가능한 케이스가 1개이므로, 이를 먼저 초기화 해주자.
for (let h = 0; h < 31; h++) {
  for (let w = 0; w < 31; w++) {
    // 반쪽 짜리가 한 알짜리보다 많은 경우는 무시해야 한다.
    if (h > w) continue;
    // 반쪽 짜리가 0개인 경우에는 아직 W 하나밖에 없는 케이스이므로 1개다.
    if (h === 0) dp[w][h] = 1;
    // 그렇지 않은 경우, 현재 문자열을 w가 한 개 부족한 케이스와 h가 한 개 부족한 케이스를 합친다.
    else dp[w][h] = dp[w - 1][h] + dp[w][h - 1];
  }
}

for (const number of input) {
  if (!number) break;
  // 알약이 N개라는 의미는 W도 N개고 H도 N개인 케이스에 대해서 구하라는 의미.
  console.log(dp[number][number]);
}